// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: api.proto

package guestapi

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// GuestAPIClient is the client API for GuestAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestAPIClient interface {
	AddApp(ctx context.Context, in *AddAppReq, opts ...grpc.CallOption) (*AddAppResp, error)
	DisableApp(ctx context.Context, in *DisableAppReq, opts ...grpc.CallOption) (*DisableAppResp, error)
	RunOnMac(ctx context.Context, opts ...grpc.CallOption) (GuestAPI_RunOnMacClient, error)
	// Run a command on the base OS
	Console(ctx context.Context, opts ...grpc.CallOption) (GuestAPI_ConsoleClient, error)
	TrimMemory(ctx context.Context, in *TrimMemoryReq, opts ...grpc.CallOption) (*TrimMemoryResp, error)
}

type guestAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestAPIClient(cc grpc.ClientConnInterface) GuestAPIClient {
	return &guestAPIClient{cc}
}

func (c *guestAPIClient) AddApp(ctx context.Context, in *AddAppReq, opts ...grpc.CallOption) (*AddAppResp, error) {
	out := new(AddAppResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.GuestAPI/AddApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestAPIClient) DisableApp(ctx context.Context, in *DisableAppReq, opts ...grpc.CallOption) (*DisableAppResp, error) {
	out := new(DisableAppResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.GuestAPI/DisableApp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestAPIClient) RunOnMac(ctx context.Context, opts ...grpc.CallOption) (GuestAPI_RunOnMacClient, error) {
	stream, err := c.cc.NewStream(ctx, &GuestAPI_ServiceDesc.Streams[0], "/dev.lab47.isle.guestapi.GuestAPI/RunOnMac", opts...)
	if err != nil {
		return nil, err
	}
	x := &guestAPIRunOnMacClient{stream}
	return x, nil
}

type GuestAPI_RunOnMacClient interface {
	Send(*RunInput) error
	Recv() (*RunOutput, error)
	grpc.ClientStream
}

type guestAPIRunOnMacClient struct {
	grpc.ClientStream
}

func (x *guestAPIRunOnMacClient) Send(m *RunInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *guestAPIRunOnMacClient) Recv() (*RunOutput, error) {
	m := new(RunOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *guestAPIClient) Console(ctx context.Context, opts ...grpc.CallOption) (GuestAPI_ConsoleClient, error) {
	stream, err := c.cc.NewStream(ctx, &GuestAPI_ServiceDesc.Streams[1], "/dev.lab47.isle.guestapi.GuestAPI/Console", opts...)
	if err != nil {
		return nil, err
	}
	x := &guestAPIConsoleClient{stream}
	return x, nil
}

type GuestAPI_ConsoleClient interface {
	Send(*RunInput) error
	Recv() (*RunOutput, error)
	grpc.ClientStream
}

type guestAPIConsoleClient struct {
	grpc.ClientStream
}

func (x *guestAPIConsoleClient) Send(m *RunInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *guestAPIConsoleClient) Recv() (*RunOutput, error) {
	m := new(RunOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *guestAPIClient) TrimMemory(ctx context.Context, in *TrimMemoryReq, opts ...grpc.CallOption) (*TrimMemoryResp, error) {
	out := new(TrimMemoryResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.GuestAPI/TrimMemory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestAPIServer is the server API for GuestAPI service.
// All implementations should embed UnimplementedGuestAPIServer
// for forward compatibility
type GuestAPIServer interface {
	AddApp(context.Context, *AddAppReq) (*AddAppResp, error)
	DisableApp(context.Context, *DisableAppReq) (*DisableAppResp, error)
	RunOnMac(GuestAPI_RunOnMacServer) error
	// Run a command on the base OS
	Console(GuestAPI_ConsoleServer) error
	TrimMemory(context.Context, *TrimMemoryReq) (*TrimMemoryResp, error)
}

// UnimplementedGuestAPIServer should be embedded to have forward compatible implementations.
type UnimplementedGuestAPIServer struct {
}

func (UnimplementedGuestAPIServer) AddApp(context.Context, *AddAppReq) (*AddAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddApp not implemented")
}
func (UnimplementedGuestAPIServer) DisableApp(context.Context, *DisableAppReq) (*DisableAppResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableApp not implemented")
}
func (UnimplementedGuestAPIServer) RunOnMac(GuestAPI_RunOnMacServer) error {
	return status.Errorf(codes.Unimplemented, "method RunOnMac not implemented")
}
func (UnimplementedGuestAPIServer) Console(GuestAPI_ConsoleServer) error {
	return status.Errorf(codes.Unimplemented, "method Console not implemented")
}
func (UnimplementedGuestAPIServer) TrimMemory(context.Context, *TrimMemoryReq) (*TrimMemoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrimMemory not implemented")
}

// UnsafeGuestAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestAPIServer will
// result in compilation errors.
type UnsafeGuestAPIServer interface {
	mustEmbedUnimplementedGuestAPIServer()
}

func RegisterGuestAPIServer(s grpc.ServiceRegistrar, srv GuestAPIServer) {
	s.RegisterService(&GuestAPI_ServiceDesc, srv)
}

func _GuestAPI_AddApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestAPIServer).AddApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.GuestAPI/AddApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestAPIServer).AddApp(ctx, req.(*AddAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestAPI_DisableApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestAPIServer).DisableApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.GuestAPI/DisableApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestAPIServer).DisableApp(ctx, req.(*DisableAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _GuestAPI_RunOnMac_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GuestAPIServer).RunOnMac(&guestAPIRunOnMacServer{stream})
}

type GuestAPI_RunOnMacServer interface {
	Send(*RunOutput) error
	Recv() (*RunInput, error)
	grpc.ServerStream
}

type guestAPIRunOnMacServer struct {
	grpc.ServerStream
}

func (x *guestAPIRunOnMacServer) Send(m *RunOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *guestAPIRunOnMacServer) Recv() (*RunInput, error) {
	m := new(RunInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GuestAPI_Console_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GuestAPIServer).Console(&guestAPIConsoleServer{stream})
}

type GuestAPI_ConsoleServer interface {
	Send(*RunOutput) error
	Recv() (*RunInput, error)
	grpc.ServerStream
}

type guestAPIConsoleServer struct {
	grpc.ServerStream
}

func (x *guestAPIConsoleServer) Send(m *RunOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *guestAPIConsoleServer) Recv() (*RunInput, error) {
	m := new(RunInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _GuestAPI_TrimMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrimMemoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestAPIServer).TrimMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.GuestAPI/TrimMemory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestAPIServer).TrimMemory(ctx, req.(*TrimMemoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// GuestAPI_ServiceDesc is the grpc.ServiceDesc for GuestAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GuestAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dev.lab47.isle.guestapi.GuestAPI",
	HandlerType: (*GuestAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddApp",
			Handler:    _GuestAPI_AddApp_Handler,
		},
		{
			MethodName: "DisableApp",
			Handler:    _GuestAPI_DisableApp_Handler,
		},
		{
			MethodName: "TrimMemory",
			Handler:    _GuestAPI_TrimMemory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunOnMac",
			Handler:       _GuestAPI_RunOnMac_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Console",
			Handler:       _GuestAPI_Console_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

// HostAPIClient is the client API for HostAPI service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HostAPIClient interface {
	RunOnMac(ctx context.Context, opts ...grpc.CallOption) (HostAPI_RunOnMacClient, error)
	Running(ctx context.Context, in *RunningReq, opts ...grpc.CallOption) (*RunningResp, error)
	StartPortForward(ctx context.Context, in *StartPortForwardReq, opts ...grpc.CallOption) (*StartPortForwardResp, error)
	CancelPortForward(ctx context.Context, in *CancelPortForwardReq, opts ...grpc.CallOption) (*CancelPortForwardResp, error)
	TrimMemory(ctx context.Context, in *TrimMemoryReq, opts ...grpc.CallOption) (*TrimMemoryResp, error)
}

type hostAPIClient struct {
	cc grpc.ClientConnInterface
}

func NewHostAPIClient(cc grpc.ClientConnInterface) HostAPIClient {
	return &hostAPIClient{cc}
}

func (c *hostAPIClient) RunOnMac(ctx context.Context, opts ...grpc.CallOption) (HostAPI_RunOnMacClient, error) {
	stream, err := c.cc.NewStream(ctx, &HostAPI_ServiceDesc.Streams[0], "/dev.lab47.isle.guestapi.HostAPI/RunOnMac", opts...)
	if err != nil {
		return nil, err
	}
	x := &hostAPIRunOnMacClient{stream}
	return x, nil
}

type HostAPI_RunOnMacClient interface {
	Send(*RunInput) error
	Recv() (*RunOutput, error)
	grpc.ClientStream
}

type hostAPIRunOnMacClient struct {
	grpc.ClientStream
}

func (x *hostAPIRunOnMacClient) Send(m *RunInput) error {
	return x.ClientStream.SendMsg(m)
}

func (x *hostAPIRunOnMacClient) Recv() (*RunOutput, error) {
	m := new(RunOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *hostAPIClient) Running(ctx context.Context, in *RunningReq, opts ...grpc.CallOption) (*RunningResp, error) {
	out := new(RunningResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.HostAPI/Running", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostAPIClient) StartPortForward(ctx context.Context, in *StartPortForwardReq, opts ...grpc.CallOption) (*StartPortForwardResp, error) {
	out := new(StartPortForwardResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.HostAPI/StartPortForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostAPIClient) CancelPortForward(ctx context.Context, in *CancelPortForwardReq, opts ...grpc.CallOption) (*CancelPortForwardResp, error) {
	out := new(CancelPortForwardResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.HostAPI/CancelPortForward", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hostAPIClient) TrimMemory(ctx context.Context, in *TrimMemoryReq, opts ...grpc.CallOption) (*TrimMemoryResp, error) {
	out := new(TrimMemoryResp)
	err := c.cc.Invoke(ctx, "/dev.lab47.isle.guestapi.HostAPI/TrimMemory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HostAPIServer is the server API for HostAPI service.
// All implementations should embed UnimplementedHostAPIServer
// for forward compatibility
type HostAPIServer interface {
	RunOnMac(HostAPI_RunOnMacServer) error
	Running(context.Context, *RunningReq) (*RunningResp, error)
	StartPortForward(context.Context, *StartPortForwardReq) (*StartPortForwardResp, error)
	CancelPortForward(context.Context, *CancelPortForwardReq) (*CancelPortForwardResp, error)
	TrimMemory(context.Context, *TrimMemoryReq) (*TrimMemoryResp, error)
}

// UnimplementedHostAPIServer should be embedded to have forward compatible implementations.
type UnimplementedHostAPIServer struct {
}

func (UnimplementedHostAPIServer) RunOnMac(HostAPI_RunOnMacServer) error {
	return status.Errorf(codes.Unimplemented, "method RunOnMac not implemented")
}
func (UnimplementedHostAPIServer) Running(context.Context, *RunningReq) (*RunningResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Running not implemented")
}
func (UnimplementedHostAPIServer) StartPortForward(context.Context, *StartPortForwardReq) (*StartPortForwardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartPortForward not implemented")
}
func (UnimplementedHostAPIServer) CancelPortForward(context.Context, *CancelPortForwardReq) (*CancelPortForwardResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelPortForward not implemented")
}
func (UnimplementedHostAPIServer) TrimMemory(context.Context, *TrimMemoryReq) (*TrimMemoryResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TrimMemory not implemented")
}

// UnsafeHostAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HostAPIServer will
// result in compilation errors.
type UnsafeHostAPIServer interface {
	mustEmbedUnimplementedHostAPIServer()
}

func RegisterHostAPIServer(s grpc.ServiceRegistrar, srv HostAPIServer) {
	s.RegisterService(&HostAPI_ServiceDesc, srv)
}

func _HostAPI_RunOnMac_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HostAPIServer).RunOnMac(&hostAPIRunOnMacServer{stream})
}

type HostAPI_RunOnMacServer interface {
	Send(*RunOutput) error
	Recv() (*RunInput, error)
	grpc.ServerStream
}

type hostAPIRunOnMacServer struct {
	grpc.ServerStream
}

func (x *hostAPIRunOnMacServer) Send(m *RunOutput) error {
	return x.ServerStream.SendMsg(m)
}

func (x *hostAPIRunOnMacServer) Recv() (*RunInput, error) {
	m := new(RunInput)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _HostAPI_Running_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunningReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostAPIServer).Running(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.HostAPI/Running",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostAPIServer).Running(ctx, req.(*RunningReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostAPI_StartPortForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPortForwardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostAPIServer).StartPortForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.HostAPI/StartPortForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostAPIServer).StartPortForward(ctx, req.(*StartPortForwardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostAPI_CancelPortForward_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelPortForwardReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostAPIServer).CancelPortForward(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.HostAPI/CancelPortForward",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostAPIServer).CancelPortForward(ctx, req.(*CancelPortForwardReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _HostAPI_TrimMemory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrimMemoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HostAPIServer).TrimMemory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dev.lab47.isle.guestapi.HostAPI/TrimMemory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HostAPIServer).TrimMemory(ctx, req.(*TrimMemoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

// HostAPI_ServiceDesc is the grpc.ServiceDesc for HostAPI service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HostAPI_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "dev.lab47.isle.guestapi.HostAPI",
	HandlerType: (*HostAPIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Running",
			Handler:    _HostAPI_Running_Handler,
		},
		{
			MethodName: "StartPortForward",
			Handler:    _HostAPI_StartPortForward_Handler,
		},
		{
			MethodName: "CancelPortForward",
			Handler:    _HostAPI_CancelPortForward_Handler,
		},
		{
			MethodName: "TrimMemory",
			Handler:    _HostAPI_TrimMemory_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunOnMac",
			Handler:       _HostAPI_RunOnMac_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}
